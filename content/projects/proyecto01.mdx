---
title: "An谩lisis de datos prueba t茅cnica en Flybondi con SQL"
date: 2025-04-21
---

# An谩lisis de datos en Flybondi

En este post, exploraremos c贸mo abordar el an谩lisis de datos de una prueba t茅cnica realizada para Flybondi utilizando SQL. Este an谩lisis se centra en la extracci贸n de informaci贸n clave desde una base de datos relacional.

##  Objetivo

El objetivo principal es identificar patrones, tendencias y m茅tricas relevantes a partir de los datos proporcionados en la prueba t茅cnica. Esto incluye:

- Consultar datos de vuelos
- Analizar el rendimiento de las rutas
- Calcular m茅tricas operacionales clave
- Identificar posibles 谩reas de mejora en la operaci贸n
- Detectar patrones de demanda estacional

## Estructura de la Base de Datos


Principales tablas utilizadas:

1. `vuelos`:
   - flight_id (PK)
   - route_id (FK)
   - departure_time
   - arrival_time
   - available_seats
   - tickets_sold
   - base_price

2. `rutas`:
   - route_id (PK)
   - origin_airport
   - destination_airport
   - distance_km
   - flight_duration

3. `pasajeros`:
   - passenger_id (PK)
   - flight_id (FK)
   - ticket_class
   - purchase_date
   - ticket_price

## Pasos del an谩lisis

### 1. Conexi贸n a la base de datos
Configuraci贸n inicial usando PostgreSQL con DBeaver:
```sql
-- Conexi贸n a la instancia RDS
\connect postgresql://user:password@flybondi-db.region.rds.amazonaws.com:5432/flybondi_db
```

### 2. Exploraci贸n inicial de los datos
An谩lisis de completitud y distribuci贸n inicial:
```sql
-- Conteo de registros por tabla
SELECT 
  (SELECT COUNT(*) FROM vuelos) AS total_vuelos,
  (SELECT COUNT(*) FROM rutas) AS total_rutas,
  (SELECT COUNT(*) FROM pasajeros) AS total_pasajeros;

-- Verificaci贸n de duplicados en vuelos
SELECT flight_id, COUNT(*) 
FROM vuelos 
GROUP BY flight_id 
HAVING COUNT(*) > 1;
```

### 3. Limpieza y preparaci贸n de datos
```sql
-- Manejo de valores nulos en horarios
UPDATE vuelos
SET departure_time = NOW() - INTERVAL '1 day'
WHERE departure_time IS NULL;

-- Normalizaci贸n de nombres de aeropuertos
UPDATE rutas
SET origin_airport = INITCAP(LOWER(origin_airport)),
    destination_airport = INITCAP(LOWER(destination_airport));
```

### 4. An谩lisis avanzado
Ocupaci贸n de vuelos:
```sql
SELECT 
  v.flight_id,
  v.tickets_sold,
  v.available_seats,
  ROUND((v.tickets_sold::FLOAT / v.available_seats) * 100, 2) AS occupancy_rate
FROM vuelos v
ORDER BY occupancy_rate DESC;
```

### 5. Rentabilidad por ruta
```sql
WITH route_revenue AS (
  SELECT 
    r.route_id,
    SUM(p.ticket_price) AS total_revenue,
    COUNT(DISTINCT v.flight_id) AS num_flights
  FROM rutas r
  JOIN vuelos v ON r.route_id = v.route_id
  JOIN pasajeros p ON v.flight_id = p.flight_id
  GROUP BY r.route_id
)
SELECT 
  route_id,
  total_revenue,
  ROUND(total_revenue / num_flights, 2) AS revenue_per_flight
FROM route_revenue;
```

### 5. KPIs clave calculados
```sql
-- Tasa promedio de ocupaci贸n diaria
SELECT 
  DATE(departure_time) AS flight_date,
  AVG((tickets_sold::FLOAT / available_seats) * 100) AS avg_daily_occupancy
FROM vuelos
GROUP BY flight_date
ORDER BY flight_date;

-- Top 5 rutas m谩s demandadas
SELECT 
  r.origin_airport || ' - ' || r.destination_airport AS route,
  COUNT(p.passenger_id) AS total_passengers
FROM rutas r
JOIN vuelos v ON r.route_id = v.route_id
JOIN pasajeros p ON v.flight_id = p.flight_id
GROUP BY route
ORDER BY total_passengers DESC
LIMIT 5;
```

### 6. Visualizaci贸n de resultados
Principales gr谩ficos generados:

Heatmap de demanda horaria:
```sql
SELECT 
  EXTRACT(HOUR FROM departure_time) AS hour,
  COUNT(*) AS total_flights
FROM vuelos
GROUP BY hour
ORDER BY hour;
```

- Serie temporal de ocupaci贸n:
```sql
SELECT 
  DATE_TRUNC('week', departure_time) AS week,
  AVG((tickets_sold::FLOAT / available_seats) * 100) AS weekly_occupancy
FROM vuelos
GROUP BY week;
```

### 7. Hallazgos clave
Patr贸n estacional: Aumento del 40% en ocupaci贸n los fines de semana

Ruta subutilizada: C贸rdoba-Posadas con solo 62% de ocupaci贸n promedio

Horario peak: 78% de los vuelos entre 6:00-9:00 AM muestran ocupaci贸n >90%

### 8. Recomendaciones operativas
Optimizar pricing din谩mico en rutas con alta demanda

Reasignar aviones a rutas estrat茅gicas

Implementar promociones para vuelos en horarios de baja ocupaci贸n

Desarrollar paquetes tur铆sticos para rutas estacionales

Conclusi贸n
Este an谩lisis demuestra c贸mo utilizar SQL para transformar datos operacionales en insights accionables, particularmente 煤til para aerol铆neas low-cost como Flybondi donde la optimizaci贸n de recursos es cr铆tica.